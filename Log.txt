
 Executing VASCO........
 Inside doAnalysis...............
 Applying SLIM modeling..............#


 Function call is an indirect call....
 Set the function pointer flag.





 Flag for function pointer is set. Entryinto the map



 Printing Global Instruction List.....#
 Index: 1	 Lhs: <x, 1 > 		 Rhs: <a, 1>
 Index: 2	 Lhs: <y, 1 > 		 Rhs: <u, 0>
 Index: 3	 Lhs: <fp, 1 > 		 Rhs: <fun, 0>
 Index: 4	 Lhs: <i, 1 > 		 Rhs: <fp, 1>
 Index: 5	 Lhs: <i1, 1 > 		 Rhs: <y, 1>
 Index: 6 Rhs: <i, 1>
 Index: 7 Rhs: <x, 1>
Time taken in Splitting Basic Block : 0 seconds
INITIALIZING CONTEXT:-
LABEL: 0
FUNCTION: main
Inflow Value: Forward:- Backward:- {  }
 Inside doAnalysisBackward..................
 Backwards Index: 2
 Backwards Index: 3
 Backwards Index: 4
 Backwards Index: 5
 Backwards Index: 6
 Backwards Index: 7
===================================[BACKWARD-0 ]===========================================

Processing instruction at INDEX = 7
OUT: {  }
 Inside computeInFromOut...................
 Rhs in loop: <x, 1>
 Instr is a USE. 
 Instr is a return stmt. IN: { x,  }
===================================[BACKWARD-0 ]===========================================

Call Instruction at INDEX = 6 is Function Pointer and Pointees are : 
 Inside getIndirectCalleeFromIN..............
 Index =  6
 Inside getFetchLRObfromIndex..............
 Rhs in loop: <i, 1>
 Get Hash name: imain

 Inside getFPandArgs..............
 Index =  6
 Inside getFetchLRObfromIndex..............
 Rhs in loop: <i, 1>
 Get Hash name: imain
===================================[BACKWARD-0 ]===========================================

Processing instruction at INDEX = 6
OUT: { x,  }IN: { i, i1,  }
===================================[BACKWARD-0 ]===========================================

Processing instruction at INDEX = 5
OUT: { i, i1,  }
 Inside computeInFromOut...................
 Fetched LHS: i1 lhs indir: 1
 Rhs in loop: <y, 1>IN: { i, y,  }
===================================[BACKWARD-0 ]===========================================

===================================[BACKWARD-0 ]===========================================

Processing instruction at INDEX = 4
OUT: { i, y,  }
 Inside computeInFromOut...................
 Fetched LHS: i lhs indir: 1
 Rhs in loop: <fp, 1>IN: { y, fp,  }
===================================[BACKWARD-0 ]===========================================

===================================[BACKWARD-0 ]===========================================

Processing instruction at INDEX = 3
OUT: { y, fp,  }
 Inside computeInFromOut...................
 Fetched LHS: fp lhs indir: 1
 Rhs in loop: <fun, 0>IN: { y,  }
===================================[BACKWARD-0 ]===========================================

===================================[BACKWARD-0 ]===========================================

Processing instruction at INDEX = 2
OUT: { y,  }
 Inside computeInFromOut...................
 Fetched LHS: y lhs indir: 1
 Rhs in loop: <u, 0>IN: {  }
===================================[BACKWARD-0 ]===========================================

 Check if LIN of BB has changed.
 Inside EqualDataFlowValuesBackward.................
 Value d1..........
 Inside printCurrLinLout............
 Value d2..........
 Inside printCurrLinLout............
 Check if LOUT of BB has changed.
 Inside EqualDataFlowValuesBackward.................
 Value d1..........
 Inside printCurrLinLout............
 Value d2..........
 Inside printCurrLinLout............
 BB is the entry block..........
 Inside getPurelyGlobalComponentBackward...............
 SLIM LOOP 
 Inside doAnalysisForward.................
 Forward Index: 2
 Forward Index: 3
 Forward Index: 4
 Forward Index: 5
 Forward Index: 6
 Forward Index: 7
===================================[FORWARD-0 ]===========================================

Processing instruction at INDEX = 2
IN: 
 Inside computeOutFromIn......................
 LHS in loop = y indir= 1
 Rhs in loop: <u, 0>
 Forward Component at OUT  ....previos component
 Inside printCurrPinPout............
 Checking backwardOUT values........
 Value: y
 ----------------------
 Normal instruction. 
 Rhs Value: u indir= 0
 Rhs indir = 0 
 Now fetching the pointees of LHS: y
 Inside while loop for Lhs
 Must points-to relation. Delete points-to pairs from OutofInst 

 Inside printCurrPinPout............{ (y, )->((u, ) , ) }
 Printing backwardOUT value Val: y 	

 Merging prev and curr POUT values
 Inside forwardMerge.................
 Printing forward values: { (y, )->((u, ) , ) }
 ----------------------------------
 Inside restrictByLivness().......
 Printing new POUT after restrictByLvness
 Inside printCurrPinPout............{ (y, )->((u, ) , ) }OUT: { (y, )->((u, ) , ) }
 Backward value is : { y,  }
===================================[FORWARD-0 ]===========================================

===================================[FORWARD-0 ]===========================================

Processing instruction at INDEX = 3
IN: { (y, )->((u, ) , ) }
 Inside computeOutFromIn......................
 LHS in loop = fp indir= 1
 Rhs in loop: <fun, 0>
 Forward Component at OUT  ....previos component
 Inside printCurrPinPout............
 Checking backwardOUT values........
 Value: y
 Value: fp
 ----------------------
 Normal instruction. 
 Rhs Value: fun indir= 0
 Rhs indir = 0 
 Now fetching the pointees of LHS: fp
 Inside while loop for Lhs
 Must points-to relation. Delete points-to pairs from OutofInst 

 Inside printCurrPinPout............{ (y, )->((u, ) , ) }{ (fp, )->((fun, ) , ) }
 Printing backwardOUT value Val: y 	 Val: fp 	

 Merging prev and curr POUT values
 Inside forwardMerge.................
 Printing forward values: { (y, )->((u, ) , ) }{ (fp, )->((fun, ) , ) }
 ----------------------------------
 Inside restrictByLivness().......
 Printing new POUT after restrictByLvness
 Inside printCurrPinPout............{ (y, )->((u, ) , ) }{ (fp, )->((fun, ) , ) }OUT: { (y, )->((u, ) , ) }{ (fp, )->((fun, ) , ) }
 Backward value is : { y, fp,  }
===================================[FORWARD-0 ]===========================================

===================================[FORWARD-0 ]===========================================

Processing instruction at INDEX = 4
IN: { (y, )->((u, ) , ) }{ (fp, )->((fun, ) , ) }
 Inside computeOutFromIn......................
 LHS in loop = i indir= 1
 Rhs in loop: <fp, 1>
 Forward Component at OUT  ....previos component
 Inside printCurrPinPout............
 Checking backwardOUT values........
 Value: i
 Value: y
 ----------------------
 Normal instruction. 
 Rhs Value: fp indir= 1
 case 2: x=t1 or t1=x or *t2=t1 
 While loop rhsIndir is 1Rhs value is a pointer
 Fetch pointees of t1 from Pin. 
 RhsValue is not an array
 PIN is not empty
 PIN is not empty
 Pointees of Rhs found in Pin. 
 Second while loop
 Verify pointee of rhs: fun
 Now fetching the pointees of LHS: i
 Inside while loop for Lhs
 Must points-to relation. Delete points-to pairs from OutofInst 

 Inside printCurrPinPout............{ (i, )->((fun, ) , ) }{ (y, )->((u, ) , ) }{ (fp, )->((fun, ) , ) }
 Printing backwardOUT value Val: i 	 Val: y 	

 Merging prev and curr POUT values
 Inside forwardMerge.................
 Printing forward values: { (i, )->((fun, ) , ) }{ (y, )->((u, ) , ) }{ (fp, )->((fun, ) , ) }
 ----------------------------------
 Inside restrictByLivness().......
 Printing new POUT after restrictByLvness
 Inside printCurrPinPout............{ (y, )->((u, ) , ) }OUT: { (y, )->((u, ) , ) }
 Backward value is : { i, y,  }
===================================[FORWARD-0 ]===========================================

===================================[FORWARD-0 ]===========================================

Processing instruction at INDEX = 5
IN: { (y, )->((u, ) , ) }
 Inside computeOutFromIn......................
 LHS in loop = i1 indir= 1
 Rhs in loop: <y, 1>
 Forward Component at OUT  ....previos component
 Inside printCurrPinPout............
 Checking backwardOUT values........
 Value: i
 Value: i1
 ----------------------
 Normal instruction. 
 Rhs Value: y indir= 1
 case 2: x=t1 or t1=x or *t2=t1 
 While loop rhsIndir is 1Rhs value is a pointer
 Fetch pointees of t1 from Pin. 
 RhsValue is not an array
 PIN is not empty
 Pointees of Rhs found in Pin. 
 Second while loop
 Verify pointee of rhs: u
 Now fetching the pointees of LHS: i1
 Inside while loop for Lhs
 Must points-to relation. Delete points-to pairs from OutofInst 

 Inside printCurrPinPout............{ (i1, )->((u, ) , ) }{ (y, )->((u, ) , ) }
 Printing backwardOUT value Val: i 	 Val: i1 	

 Merging prev and curr POUT values
 Inside forwardMerge.................
 Printing forward values: { (i1, )->((u, ) , ) }{ (y, )->((u, ) , ) }
 ----------------------------------
 Inside restrictByLivness().......
 Printing new POUT after restrictByLvness
 Inside printCurrPinPout............OUT: 
 Backward value is : { i, i1,  }
===================================[FORWARD-0 ]===========================================

Call Instruction at INDEX = 6 in Forward Analysis is Function Pointer and Pointees are : 
 Inside getIndirectCalleeFromIN..............
 Index =  6
 Inside getFetchLRObfromIndex..............
 Rhs in loop: <i, 1>
 Get Hash name: imain
Size of vector is: 0 Prev DFV is: { i, i1,  }

===================================[FORWARD-0 ]===========================================

Processing instruction at INDEX = 7
IN: 
 Inside computeOutFromIn......................
 Rhs in loop: <x, 1>
 Forward Component at OUT  ....previos component
 Inside printCurrPinPout............
 Checking backwardOUT values........
 BackwardOUT is empty.............
 ----------------------
 Instr is a USE. 
 Inside restrictByLivness().......
 Printing forward values: 
 ----------------------------------OUT: 
 Backward value is : {  }
===================================[FORWARD-0 ]===========================================

 Check if POut has changed
 Inside EqualDataFlowValuesForward...............................
 Value d1..........
 Inside printCurrPinPout............
 Value d2..........
 Inside printCurrPinPout............
 Check if PIN has changed
 Inside EqualDataFlowValuesForward...............................
 Value d1..........
 Inside printCurrPinPout............
 Value d2..........
 Inside printCurrPinPout............
 BB is the last node....
 Inside getPurelyGlobalComponentForward...........
 Inside SLIM loop Time taken by analysis: 0 seconds

 Execution ends..........
 Printing Global Instruction List.....#
 Index: 1	 Lhs: <x, 1 > 		 Rhs: <a, 1>
 Index: 2	 Lhs: <y, 1 > 		 Rhs: <u, 0>
 Index: 3	 Lhs: <fp, 1 > 		 Rhs: <fun, 0>
 Index: 4	 Lhs: <i, 1 > 		 Rhs: <fp, 1>
 Index: 5	 Lhs: <i1, 1 > 		 Rhs: <y, 1>
 Index: 6 Rhs: <i, 1>
 Index: 7 Rhs: <x, 1>

 Printing Modeled LLVM IR instructions...........#
  store i32* %a, i32** @x, align 8
  store i32* @u, i32** @y, align 8
  store void (i32*)* @fun, void (i32*)** @fp, align 8
  %i = load void (i32*)*, void (i32*)** @fp, align 8
  %i1 = load i32*, i32** @y, align 8
  call void %i(i32* %i1)
  ret i32 %i3
Memory consume: 